<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>bitchat // web</title>
<link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=VT323:wght@400&display=swap" rel="stylesheet">
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}

:root {
  --bg:     #060810;
  --bg2:    #0b0e18;
  --bg3:    #0f1420;
  --border: #1a2535;
  --green:  #00ff88;
  --green2: #00cc66;
  --cyan:   #00d4ff;
  --amber:  #ffaa00;
  --red:    #ff4455;
  --purple: #cc88ff;
  --text:   #a0bdd0;
  --dim:    #3a5570;
  --bright: #deeeff;
  --mono: 'Share Tech Mono', monospace;
  --vt:   'VT323', monospace;
}

html,body { height:100%; background:var(--bg); color:var(--text); font-family:var(--mono); font-size:13px; overflow:hidden; }

/* CRT scanlines */
body::after {
  content:''; position:fixed; inset:0;
  background: repeating-linear-gradient(0deg, transparent, transparent 3px, rgba(0,0,0,0.08) 3px, rgba(0,0,0,0.08) 4px);
  pointer-events:none; z-index:9999;
}

/* phosphor glow on focus */
body::before {
  content:''; position:fixed; inset:0;
  background: radial-gradient(ellipse 80% 60% at 50% 50%, rgba(0,50,30,0.12) 0%, transparent 70%);
  pointer-events:none; z-index:1;
}

/* ── LAYOUT ── */
#app {
  display:grid;
  grid-template-rows: 44px 1fr 48px;
  grid-template-columns: 190px 1fr;
  height:100vh;
  border:1px solid var(--border);
  position:relative; z-index:2;
}

/* ── HEADER ── */
#header {
  grid-column:1/-1;
  background:var(--bg2);
  border-bottom:1px solid var(--border);
  display:flex; align-items:center; gap:16px; padding:0 14px;
}

#logo {
  font-family:var(--vt); font-size:26px; letter-spacing:5px;
  color:var(--green);
  text-shadow: 0 0 12px var(--green), 0 0 30px rgba(0,255,136,0.3);
  flex-shrink:0;
}

#header-pills { display:flex; gap:8px; align-items:center; flex:1; }

.pill {
  padding:2px 9px; border:1px solid; font-size:10px; letter-spacing:1.5px;
  font-family:var(--mono); text-transform:uppercase; transition: all .2s;
}
.pill.off  { border-color:var(--dim); color:var(--dim); }
.pill.on   { border-color:var(--green); color:var(--green); box-shadow:0 0 6px rgba(0,255,136,0.2); }
.pill.scan { border-color:var(--amber); color:var(--amber); }

#btn-scan {
  margin-left:auto; padding:5px 18px;
  background:transparent; border:1px solid var(--cyan); color:var(--cyan);
  font-family:var(--mono); font-size:11px; letter-spacing:2px; cursor:pointer;
  text-transform:uppercase; transition:all .2s;
}
#btn-scan:hover { background:var(--cyan); color:var(--bg); box-shadow:0 0 16px rgba(0,212,255,0.4); }
#btn-scan:disabled { border-color:var(--dim); color:var(--dim); cursor:not-allowed; background:transparent; box-shadow:none; }

/* ── SIDEBAR ── */
#sidebar {
  background:var(--bg2); border-right:1px solid var(--border);
  display:flex; flex-direction:column; overflow:hidden;
}

.sb-head {
  padding:6px 12px; font-size:9px; letter-spacing:3px; text-transform:uppercase;
  color:var(--dim); background:var(--bg3); border-bottom:1px solid var(--border);
  display:flex; align-items:center; gap:6px;
}

.sb-head::before { content:'//'; color:var(--green2); }

.ch-item {
  padding:5px 14px; cursor:pointer; font-size:12px;
  border-left:2px solid transparent; transition:all .1s;
  display:flex; align-items:center; gap:6px; color:var(--text);
}
.ch-item:hover { background:rgba(255,255,255,0.03); color:var(--bright); }
.ch-item.active { border-left-color:var(--green); color:var(--green); background:rgba(0,255,136,0.04); }

.peer-item {
  padding:5px 14px; font-size:11px; display:flex; align-items:center; gap:7px;
}
.dot { width:6px; height:6px; border-radius:50%; flex-shrink:0; }
.dot.fresh  { background:var(--green); box-shadow:0 0 5px var(--green); }
.dot.stale  { background:var(--amber); box-shadow:0 0 5px var(--amber); }
.dot.gone   { background:var(--dim); }

.sb-section { border-bottom:1px solid var(--border); }
#peer-section { flex:1; overflow-y:auto; }

/* ── MAIN ── */
#main { display:flex; flex-direction:column; overflow:hidden; min-width:0; }

#ch-bar {
  padding:5px 14px; background:var(--bg2); border-bottom:1px solid var(--border);
  font-size:11px; color:var(--dim); display:flex; align-items:center; gap:8px; flex-shrink:0;
}
#ch-bar-name { color:var(--cyan); font-size:13px; letter-spacing:.5px; }

/* ── MESSAGES ── */
#messages {
  flex:1; overflow-y:auto; padding:6px 0;
  scroll-behavior:smooth; position:relative;
}
#messages::-webkit-scrollbar { width:3px; }
#messages::-webkit-scrollbar-thumb { background:var(--border); }

.msg {
  display:flex; gap:0; padding:2px 14px; line-height:1.65;
  animation: msgIn .18s ease; min-height:22px;
}
.msg:hover { background:rgba(255,255,255,0.018); }

@keyframes msgIn {
  from { opacity:0; transform:translateY(3px); }
  to   { opacity:1; transform:translateY(0); }
}

.m-time  { color:var(--dim); font-size:10px; min-width:40px; flex-shrink:0; padding-top:2px; }
.m-nick  { min-width:110px; max-width:110px; flex-shrink:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; padding-right:6px; }
.m-nick.self    { color:var(--green); }
.m-nick.sys     { color:var(--dim); font-style:italic; }
.m-nick.peer    { color:var(--cyan); }
.m-nick.pm      { color:var(--purple); }
.m-text { color:var(--text); word-break:break-word; flex:1; }
.msg.sys-msg .m-text    { color:var(--dim); font-style:italic; }
.msg.announce .m-text   { color:var(--amber); }
.msg.ok .m-text         { color:var(--green2); }
.msg.err .m-text        { color:var(--red); }
.msg.pm-msg .m-text     { color:var(--purple); }

/* ── WELCOME ── */
#welcome {
  position:absolute; inset:0; display:flex; flex-direction:column;
  align-items:center; justify-content:center; gap:14px; text-align:center;
  pointer-events:none;
}
#welcome pre {
  font-family:var(--vt); font-size:22px; color:var(--green);
  text-shadow: 0 0 15px var(--green), 0 0 40px rgba(0,255,136,0.2);
  line-height:1.1; letter-spacing:2px;
}
#welcome .sub   { font-size:12px; color:var(--dim); line-height:1.9; }
#welcome .hint  { font-size:11px; color:var(--dim); margin-top:4px; }
#welcome .hint span { color:var(--cyan); }

/* ── INPUT ── */
#input-bar {
  grid-column:1/-1;
  background:var(--bg2); border-top:1px solid var(--border);
  display:flex; align-items:center; gap:8px; padding:0 12px;
}
#input-prompt { color:var(--green); flex-shrink:0; font-size:13px; white-space:nowrap; }
#input-prompt em { color:var(--dim); font-style:normal; }
#txt {
  flex:1; background:transparent; border:none; outline:none;
  color:var(--bright); font-family:var(--mono); font-size:13px; caret-color:var(--green);
  padding:0;
}
#txt::placeholder { color:var(--dim); }
#btn-send {
  padding:6px 14px; background:transparent; border:1px solid var(--green2);
  color:var(--green2); font-family:var(--mono); font-size:11px; letter-spacing:1.5px;
  cursor:pointer; text-transform:uppercase; transition:all .15s; flex-shrink:0;
}
#btn-send:hover { background:var(--green2); color:var(--bg); }

/* autocomplete dropdown */
#autocomplete {
  position:absolute; bottom:52px; left:200px; background:var(--bg3);
  border:1px solid var(--border); min-width:180px; z-index:100; display:none;
}
.ac-item {
  padding:4px 12px; font-size:12px; cursor:pointer; color:var(--text);
}
.ac-item:hover,.ac-item.sel { background:rgba(0,212,255,0.1); color:var(--cyan); }

/* ── NO BLE banner ── */
#no-ble {
  display:none; position:fixed; top:52px; left:50%; transform:translateX(-50%);
  background:var(--bg3); border:1px solid var(--red); padding:8px 20px;
  color:var(--red); font-size:12px; letter-spacing:.5px; z-index:500;
  text-align:center; max-width:500px;
}
</style>
</head>
<body>

<div id="app">

  <!-- HEADER -->
  <header id="header">
    <div id="logo">BITCHAT</div>
    <div id="header-pills">
      <span id="pill-net"  class="pill off">◎ OFFLINE</span>
      <span id="pill-ble"  class="pill off">BLE</span>
      <span id="pill-peer" class="pill off">0 PEERS</span>
    </div>
    <button id="btn-scan" onclick="doScan()">⟁ SCAN</button>
  </header>

  <!-- SIDEBAR -->
  <aside id="sidebar">
    <div class="sb-section">
      <div class="sb-head">channels</div>
      <div id="ch-list">
        <div class="ch-item active" onclick="switchCh('#mesh')"># mesh</div>
      </div>
    </div>
    <div id="peer-section">
      <div class="sb-head">peers</div>
      <div id="peer-list">
        <div style="padding:8px 14px;font-size:11px;color:var(--dim)">scanning…</div>
      </div>
    </div>
  </aside>

  <!-- MAIN -->
  <main id="main">
    <div id="ch-bar">
      <span id="ch-bar-name">#mesh</span>
      <span>—</span>
      <span>bluetooth mesh · no servers · no internet required</span>
    </div>

    <div id="messages">
      <div id="welcome">
        <pre>
 ██████╗ ██╗████████╗ ██████╗██╗  ██╗ █████╗ ████████╗
 ██╔══██╗██║╚══██╔══╝██╔════╝██║  ██║██╔══██╗╚══██╔══╝
 ██████╔╝██║   ██║   ██║     ███████║███████║   ██║   
 ██╔══██╗██║   ██║   ██║     ██╔══██║██╔══██║   ██║   
 ██████╔╝██║   ██║   ╚██████╗██║  ██║██║  ██║   ██║   
 ╚═════╝ ╚═╝   ╚═╝    ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝  
        </pre>
        <div class="sub">
          peer-to-peer bluetooth mesh chat<br>
          no servers · no internet · no accounts<br>
          compatible with native bitchat iOS &amp; Android
        </div>
        <div class="hint">
          <span>/help</span> for commands &nbsp;·&nbsp;
          <span>⟁ SCAN</span> to find peers &nbsp;·&nbsp;
          <span>/nick &lt;name&gt;</span> to set your name
        </div>
      </div>
    </div>
  </main>

  <!-- INPUT BAR -->
  <div id="input-bar">
    <div id="input-prompt"><span id="myNickEl">anon</span><em>@mesh:~$&nbsp;</em></div>
    <input id="txt" type="text" autocomplete="off" autocorrect="off" spellcheck="false"
      placeholder="type a message or /help for commands…"
      oninput="onInput()" onkeydown="onKey(event)">
    <button id="btn-send" onclick="sendMsg()">SEND</button>
  </div>

  <!-- Autocomplete -->
  <div id="autocomplete" role="listbox"></div>
</div>

<!-- No BLE warning -->
<div id="no-ble">
  ⚠ Web Bluetooth unavailable — use <strong>Chrome</strong> or <strong>Edge</strong> on a Bluetooth-enabled device
</div>

<script>
'use strict';
// ═══════════════════════════════════════════════════════════
//  BITCHAT WEB  –  Web Bluetooth P2P Mesh Chat
//  Compatible with native BitChat iOS / Android
// ═══════════════════════════════════════════════════════════

// ── BLE UUIDs (from bitchat protocol) ──
const SVC_UUID  = 'f47b5e2d-4a9e-4c5a-9b3f-8e1d2c3a4b5c';
const CHAR_UUID = 'a1b2c3d4-e5f6-4a5b-8c9d-0e1f2a3b4c5d';

// ── Packet Types ──
const T = {
  ANNOUNCE:  0x01,
  MESSAGE:   0x02,
  PRIVATE:   0x03,
  LEAVE:     0x04,
  CH_JOIN:   0x05,
  ACK:       0x06,
};

// ── State ──
const enc = new TextEncoder(), dec = new TextDecoder();
let myNick   = 'web_' + Math.random().toString(36).slice(2,6);
let myPeerId = Array.from(crypto.getRandomValues(new Uint8Array(6)))
                    .map(b=>b.toString(16).padStart(2,'0')).join('');
let curCh    = '#mesh';
let conns    = new Map();   // deviceId → { device, char, nick }
let peers    = new Map();   // peerId → { nick, lastSeen, deviceId }
let seen     = new Set();
let channels = new Set(['#mesh']);
let history  = [], histIdx = -1;
let acItems  = [], acSel = -1;

// ── DOM refs ──
const $msgs    = () => document.getElementById('messages');
const $peerEl  = () => document.getElementById('peer-list');
const $chEl    = () => document.getElementById('ch-list');
const $txt     = () => document.getElementById('txt');
const $welcome = () => document.getElementById('welcome');
const $ac      = () => document.getElementById('autocomplete');

// ════════════════════════════════════════
//  BINARY PROTOCOL
// ════════════════════════════════════════

/*
 Packet Layout:
 [1] version = 1
 [1] type
 [1] TTL (7 = new, decremented on relay)
 [8] message ID (random)
 [4] timestamp (unix seconds, big-endian)
 [1] peerIdLen
 [N] peerId  (UTF-8)
 [1] nickLen
 [N] nick    (UTF-8)
 [*] payload (type-dependent)
*/

function encode(type, payload, ttl=7) {
  const msgId = crypto.getRandomValues(new Uint8Array(8));
  const ts = Math.floor(Date.now()/1000);
  const pidB = enc.encode(myPeerId);
  const nkB  = enc.encode(myNick);
  const off0 = 1+1+1+8+4+1+pidB.length+1+nkB.length;
  const buf = new Uint8Array(off0 + payload.length);
  const dv  = new DataView(buf.buffer);
  let p = 0;
  buf[p++] = 1;        // version
  buf[p++] = type;     // type
  buf[p++] = ttl;      // TTL
  buf.set(msgId, p); p += 8;
  dv.setUint32(p, ts, false); p += 4;
  buf[p++] = pidB.length;
  buf.set(pidB, p); p += pidB.length;
  buf[p++] = nkB.length;
  buf.set(nkB, p); p += nkB.length;
  buf.set(payload, p);
  return buf;
}

function decode(bytes) {
  try {
    const dv = new DataView(bytes.buffer || bytes);
    let p = 0;
    const version = bytes[p++];
    if (version !== 1) return null;
    const type = bytes[p++];
    const ttl  = bytes[p++];
    const msgId = [...bytes.slice(p, p+8)].map(b=>b.toString(16).padStart(2,'0')).join('');
    p += 8;
    const ts = dv.getUint32(p, false); p += 4;
    const pidLen = bytes[p++];
    const peerId = dec.decode(bytes.slice(p, p+pidLen)); p += pidLen;
    let nick = peerId;
    if (p < bytes.length) {
      const nkLen = bytes[p++];
      if (nkLen > 0 && p+nkLen <= bytes.length) {
        nick = dec.decode(bytes.slice(p, p+nkLen)); p += nkLen;
      }
    }
    const payload = bytes.slice(p);
    return { version, type, ttl, msgId, ts, peerId, nick, payload };
  } catch { return null; }
}

function msgPayload(text, ch) {
  const chB = enc.encode(ch || '');
  const txB = enc.encode(text);
  const buf = new Uint8Array(1+chB.length+2+txB.length);
  let p = 0;
  buf[p++] = chB.length;
  buf.set(chB, p); p += chB.length;
  buf[p++] = (txB.length>>8)&0xff;
  buf[p++] = txB.length&0xff;
  buf.set(txB, p);
  return buf;
}

function parseMsgPayload(b) {
  try {
    let p=0;
    const chLen=b[p++];
    const ch = dec.decode(b.slice(p,p+chLen)); p+=chLen;
    const txLen=(b[p]<<8)|b[p+1]; p+=2;
    const text=dec.decode(b.slice(p,p+txLen));
    return { ch: ch||'#mesh', text };
  } catch { return null; }
}

// ════════════════════════════════════════
//  BLUETOOTH
// ════════════════════════════════════════

async function doScan() {
  if (!navigator.bluetooth) {
    document.getElementById('no-ble').style.display='block';
    return;
  }
  const btn = document.getElementById('btn-scan');
  btn.disabled = true; btn.textContent = '⌛ SCANNING…';
  pillScan();
  syslog('scanning for bitchat devices…','announce');

  try {
    const device = await navigator.bluetooth.requestDevice({
      filters: [{ services: [SVC_UUID] }],
      optionalServices: [SVC_UUID]
    });
    syslog(`connecting to ${device.name||'device'}…`,'announce');
    await attach(device);
  } catch(e) {
    if (e.name==='NotFoundError') syslog('scan cancelled or no devices found','sys-msg');
    else syslog('bluetooth error: '+e.message,'err');
  } finally {
    btn.disabled=false; btn.textContent='⟁ SCAN';
    refreshStatus();
  }
}

async function attach(device) {
  try {
    const srv  = await (await device.gatt.connect()).getPrimaryService(SVC_UUID);
    const char = await srv.getCharacteristic(CHAR_UUID);
    await char.startNotifications();
    char.addEventListener('characteristicvaluechanged', ev => {
      onData(new Uint8Array(ev.target.value.buffer), device.id);
    });
    device.addEventListener('gattserverdisconnected', () => onDrop(device));
    conns.set(device.id, { device, char, nick: device.name||'peer' });
    syslog(`connected to ${device.name||device.id.slice(0,8)}`,'ok');
    // Announce ourselves
    await blast(encode(T.ANNOUNCE, enc.encode(myNick), 3));
    refreshStatus(); refreshPeers();
    return true;
  } catch(e) {
    syslog('connect failed: '+e.message,'err');
    return false;
  }
}

function onDrop(device) {
  const c = conns.get(device.id);
  if (c) {
    syslog(`disconnected from ${c.nick}`,'announce');
    conns.delete(device.id);
    // remove peer
    for (const [id,p] of peers) if (p.deviceId===device.id) { peers.delete(id); break; }
    refreshStatus(); refreshPeers();
  }
}

async function sendTo(deviceId, bytes) {
  const c = conns.get(deviceId);
  if (!c) return;
  try {
    const MTU = 512;
    for (let i=0; i<bytes.length; i+=MTU) {
      await c.char.writeValueWithoutResponse(bytes.slice(i, Math.min(i+MTU, bytes.length)));
      if (bytes.length > MTU) await sleep(8);
    }
  } catch(e) { console.warn('send err', e); }
}

async function blast(bytes, exceptId=null) {
  const ps = [...conns.entries()]
    .filter(([id])=>id!==exceptId)
    .map(([id])=>sendTo(id, bytes));
  await Promise.allSettled(ps);
}

// ════════════════════════════════════════
//  INCOMING DATA
// ════════════════════════════════════════

function onData(bytes, fromId) {
  const pkt = decode(bytes);
  if (!pkt) return;

  // Dedup
  if (seen.has(pkt.msgId)) return;
  seen.add(pkt.msgId);
  if (seen.size > 800) { const it=seen.values(); for(let i=0;i<100;i++) seen.delete(it.next().value); }

  // Track peer
  if (pkt.peerId && pkt.peerId!==myPeerId) {
    peers.set(pkt.peerId, { nick:pkt.nick, lastSeen:Date.now(), deviceId:fromId });
    const c=conns.get(fromId); if(c) c.nick=pkt.nick;
    refreshPeers();
  }

  // Relay (decrement TTL)
  if (pkt.ttl>1 && pkt.peerId!==myPeerId) {
    const relay = new Uint8Array(bytes);
    relay[2] = pkt.ttl-1;
    blast(relay, fromId);
  }

  switch(pkt.type) {
    case T.ANNOUNCE:  handleAnnounce(pkt, fromId); break;
    case T.MESSAGE:   handleChat(pkt); break;
    case T.PRIVATE:   handlePrivate(pkt); break;
    case T.LEAVE:     handleLeave(pkt); break;
    case T.CH_JOIN:   handleChJoin(pkt); break;
  }
}

function handleAnnounce(pkt, fromId) {
  const nick = dec.decode(pkt.payload) || pkt.nick;
  peers.set(pkt.peerId, { nick, lastSeen:Date.now(), deviceId:fromId });
  const c=conns.get(fromId); if(c) c.nick=nick;
  syslog(`→ ${nick} joined the mesh`,'announce');
  refreshPeers();
  // reply with our own announce
  blast(encode(T.ANNOUNCE, enc.encode(myNick), 1));
}

function handleChat(pkt) {
  const d = parseMsgPayload(pkt.payload);
  if (!d) return;
  const ch = d.ch||'#mesh';
  if (ch!==curCh && ch!=='') return;
  addMsg(pkt.nick||pkt.peerId, d.text, 'peer');
  if (!channels.has(ch)) { channels.add(ch); refreshChannels(); }
}

function handlePrivate(pkt) {
  const d = parseMsgPayload(pkt.payload);
  if (!d) return;
  addMsg('[pm] '+pkt.nick, d.text, 'pm');
}

function handleLeave(pkt) {
  const p = peers.get(pkt.peerId);
  if (p) { syslog(`← ${p.nick} left`,'sys-msg'); peers.delete(pkt.peerId); refreshPeers(); }
}

function handleChJoin(pkt) {
  const ch = dec.decode(pkt.payload);
  if (ch && !channels.has(ch)) { channels.add(ch); refreshChannels(); }
}

// ════════════════════════════════════════
//  SEND / COMMANDS
// ════════════════════════════════════════

async function sendMsg() {
  const input=$txt(), raw=input.value.trim();
  if (!raw) return;
  history.unshift(raw); if(history.length>80) history.pop(); histIdx=-1;
  input.value=''; closeAc();

  if (raw[0]==='/') { await runCmd(raw); return; }

  if (conns.size===0) {
    syslog('not connected — use ⟁ SCAN to find peers','err');
  } else {
    const pl = msgPayload(raw, curCh==='#mesh'?'':curCh);
    await blast(encode(T.MESSAGE, pl));
  }
  addMsg(myNick, raw, 'self');
}

async function runCmd(raw) {
  const parts = raw.slice(1).split(/\s+/);
  const cmd = parts[0].toLowerCase();
  const args = parts.slice(1);

  switch(cmd) {
    case 'help': {
      const cmds=[
        ['/help','show this help'],
        ['/w  /who','list online peers'],
        ['/j #channel','join a channel'],
        ['/msg @user <text>','send private message'],
        ['/nick <name>','change nickname'],
        ['/clear','clear messages'],
        ['/scan','scan for more devices'],
        ['/dis','disconnect all'],
        ['/channels','list discovered channels'],
        ['/me <action>','action message'],
        ['/id','show your peer ID'],
      ];
      syslog('── available commands ──','ok');
      cmds.forEach(([c,d])=>syslog(`  ${c.padEnd(22)} ${d}`,'sys-msg'));
      break;
    }
    case 'w': case 'who': {
      if (!peers.size) { syslog('no peers online','sys-msg'); break; }
      syslog(`── ${peers.size} peer${peers.size>1?'s':''} online ──`,'ok');
      peers.forEach((p,id)=>{
        const ago=Math.round((Date.now()-p.lastSeen)/1000);
        syslog(`  ${p.nick.padEnd(18)} ${id.slice(0,8)}  ${ago}s ago`,'sys-msg');
      }); break;
    }
    case 'j': case 'join': {
      const ch=args[0]||'#mesh';
      const name=ch.startsWith('#')?ch:'#'+ch;
      channels.add(name); switchCh(name);
      const pkt=encode(T.CH_JOIN, enc.encode(name), 5);
      await blast(pkt);
      syslog(`joined ${name}`,'ok'); break;
    }
    case 'msg': {
      const target=args[0], text=args.slice(1).join(' ');
      if (!target||!text) { syslog('usage: /msg @user text','err'); break; }
      const nick=target.startsWith('@')?target.slice(1):target;
      await blast(encode(T.PRIVATE, msgPayload(text,'')));
      addMsg(`[pm→${nick}]`, text, 'pm'); break;
    }
    case 'nick': {
      const n=args[0];
      if (!n) { syslog('usage: /nick <name>','err'); break; }
      if (n.length>24) { syslog('name too long (max 24)','err'); break; }
      myNick=n;
      document.getElementById('myNickEl').textContent=myNick;
      syslog(`nickname → ${myNick}`,'ok');
      await blast(encode(T.ANNOUNCE, enc.encode(myNick), 3)); break;
    }
    case 'clear': {
      $msgs().innerHTML=''; syslog('messages cleared','sys-msg'); break;
    }
    case 'scan': await doScan(); break;
    case 'dis': {
      for (const [,c] of conns) { try{c.device.gatt.disconnect();}catch{} }
      conns.clear(); peers.clear(); refreshStatus(); refreshPeers();
      syslog('disconnected','sys-msg'); break;
    }
    case 'channels': {
      syslog('── discovered channels ──','ok');
      channels.forEach(c=>syslog('  '+c,'sys-msg')); break;
    }
    case 'me': {
      const text='* '+myNick+' '+args.join(' ');
      await blast(encode(T.MESSAGE, msgPayload(text, curCh==='#mesh'?'':curCh)));
      addMsg('*', args.join(' ')?text:text,'sys-msg'); break;
    }
    case 'id': {
      syslog(`peer id: ${myPeerId}  nick: ${myNick}`,'ok'); break;
    }
    default: syslog(`unknown command /${cmd} — type /help`,'err');
  }
}

// ════════════════════════════════════════
//  UI
// ════════════════════════════════════════

function addMsg(sender, text, nickCls) {
  const w=$welcome(); if(w) w.remove();
  const el=document.createElement('div');
  el.className='msg';
  const now=new Date();
  const t=`${now.getHours().toString().padStart(2,'0')}:${now.getMinutes().toString().padStart(2,'0')}`;
  // Highlight mentions
  let tx=esc(text).replace(new RegExp('@'+esc(myNick),'gi'), `<span style="color:var(--amber);font-weight:bold;">$&</span>`);
  // URL linkify
  tx=tx.replace(/(https?:\/\/[^\s]+)/g,'<a href="$1" target="_blank" style="color:var(--cyan)">$1</a>');
  el.innerHTML=`<span class="m-time">${t}</span><span class="m-nick ${nickCls}">${esc(sender)}</span><span class="m-text">${tx}</span>`;
  const msgs=$msgs();
  msgs.appendChild(el);
  // Auto scroll if near bottom
  if (msgs.scrollHeight-msgs.scrollTop < msgs.clientHeight+80) msgs.scrollTop=msgs.scrollHeight;
}

function syslog(text, cls) {
  const w=$welcome(); if(w) w.remove();
  const el=document.createElement('div');
  el.className='msg '+(cls||'sys-msg');
  const now=new Date();
  const t=`${now.getHours().toString().padStart(2,'0')}:${now.getMinutes().toString().padStart(2,'0')}`;
  el.innerHTML=`<span class="m-time">${t}</span><span class="m-nick sys">─sys─</span><span class="m-text">${esc(text)}</span>`;
  const msgs=$msgs();
  msgs.appendChild(el);
  msgs.scrollTop=msgs.scrollHeight;
}

function switchCh(ch) {
  curCh=ch;
  document.getElementById('ch-bar-name').textContent=ch;
  refreshChannels();
  syslog(`channel → ${ch}`,'sys-msg');
}

function refreshChannels() {
  const el=$chEl(); el.innerHTML='';
  [...channels].sort().forEach(ch=>{
    const d=document.createElement('div');
    d.className='ch-item'+(ch===curCh?' active':'');
    d.textContent=ch; d.onclick=()=>switchCh(ch);
    el.appendChild(d);
  });
}

function refreshPeers() {
  const el=$peerEl();
  if (!peers.size) {
    el.innerHTML='<div style="padding:8px 14px;font-size:11px;color:var(--dim)">no peers</div>';
    return;
  }
  el.innerHTML='';
  const now=Date.now();
  [...peers.values()].sort((a,b)=>b.lastSeen-a.lastSeen).forEach(p=>{
    const ago=(now-p.lastSeen)/1000;
    const q=ago<30?'fresh':ago<120?'stale':'gone';
    const d=document.createElement('div');
    d.className='peer-item';
    d.innerHTML=`<span class="dot ${q}"></span><span style="font-size:11px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">${esc(p.nick)}</span>`;
    el.appendChild(d);
  });
}

function refreshStatus() {
  const n=conns.size, pc=peers.size;
  const pillNet=document.getElementById('pill-net');
  const pillBle=document.getElementById('pill-ble');
  const pillPeer=document.getElementById('pill-peer');
  if (n>0) {
    pillNet.textContent=`◉ MESH ×${n}`; pillNet.className='pill on';
    pillBle.textContent='BLE ▲';         pillBle.className='pill on';
  } else {
    pillNet.textContent='◎ OFFLINE'; pillNet.className='pill off';
    pillBle.textContent='BLE';       pillBle.className='pill off';
  }
  pillPeer.textContent=`${pc} PEER${pc!==1?'S':''}`;
  pillPeer.className=pc>0?'pill on':'pill off';
}

function pillScan() {
  const p=document.getElementById('pill-net');
  p.textContent='◌ SCANNING'; p.className='pill scan';
}

// ── Autocomplete ──
const CMDS=['help','who','w','j','join','msg','nick','clear','scan','dis','channels','me','id'];

function onInput() {
  const v=$txt().value; acSel=-1;
  if (v.startsWith('/')) {
    const partial=v.slice(1).toLowerCase();
    if (!partial||partial.includes(' ')) { closeAc(); return; }
    acItems=CMDS.filter(c=>c.startsWith(partial));
    if (acItems.length>0) showAc(acItems.map(c=>'/'+c)); else closeAc();
  } else if (v.includes('@')) {
    const ai=v.lastIndexOf('@'), partial=v.slice(ai+1).toLowerCase();
    acItems=[...peers.values()].filter(p=>p.nick.toLowerCase().startsWith(partial)).map(p=>p.nick);
    if (acItems.length>0) showAc(acItems); else closeAc();
  } else if (v.startsWith('#')||v.includes(' #')) {
    const ai=v.lastIndexOf('#'), partial=v.slice(ai+1).toLowerCase();
    acItems=[...channels].filter(c=>c.slice(1).startsWith(partial));
    if (acItems.length>0) showAc(acItems); else closeAc();
  } else closeAc();
}

function showAc(items) {
  const ac=$ac(); ac.innerHTML=''; ac.style.display='block';
  items.slice(0,8).forEach((it,i)=>{
    const d=document.createElement('div');
    d.className='ac-item'; d.textContent=it;
    d.onmousedown=e=>{ e.preventDefault(); applyAc(it); };
    ac.appendChild(d);
  });
}

function closeAc() { $ac().style.display='none'; acItems=[]; acSel=-1; }

function applyAc(val) {
  const input=$txt(), v=input.value;
  if (val.startsWith('/')) {
    input.value=val+' ';
  } else if (v.includes('@')) {
    input.value=v.slice(0, v.lastIndexOf('@')+1)+val+' ';
  } else if (v.includes('#')) {
    input.value=v.slice(0, v.lastIndexOf('#'))+val+' ';
  }
  closeAc(); input.focus();
}

function onKey(e) {
  const ac=$ac();
  if (ac.style.display!=='none') {
    const items=ac.querySelectorAll('.ac-item');
    if (e.key==='ArrowDown') { e.preventDefault(); acSel=Math.min(acSel+1,items.length-1); items.forEach((el,i)=>el.classList.toggle('sel',i===acSel)); return; }
    if (e.key==='ArrowUp')   { e.preventDefault(); acSel=Math.max(acSel-1,0);              items.forEach((el,i)=>el.classList.toggle('sel',i===acSel)); return; }
    if (e.key==='Tab'||e.key==='Enter') {
      if (acSel>=0 && items[acSel]) { e.preventDefault(); applyAc(items[acSel].textContent); return; }
      if (e.key==='Tab') { e.preventDefault(); if(items[0]) applyAc(items[0].textContent); return; }
    }
    if (e.key==='Escape') { closeAc(); return; }
  }
  if (e.key==='Enter') { sendMsg(); return; }
  if (e.key==='ArrowUp') { e.preventDefault(); if(histIdx<history.length-1){histIdx++;$txt().value=history[histIdx]||'';} }
  if (e.key==='ArrowDown') { e.preventDefault(); if(histIdx>0){histIdx--;$txt().value=history[histIdx];}else{histIdx=-1;$txt().value='';} }
  if (e.key==='Escape') { closeAc(); }
}

// ── Helpers ──
const esc = s => String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
const sleep = ms => new Promise(r=>setTimeout(r,ms));

// ── Background keepalive ──
setInterval(()=>{
  if (conns.size>0) blast(encode(T.ANNOUNCE, enc.encode(myNick), 2));
}, 60000);

// ── Stale peer cleanup ──
setInterval(()=>{
  const now=Date.now(); let changed=false;
  for(const [id,p] of peers) if(now-p.lastSeen>5*60000){peers.delete(id);changed=true;}
  if(changed) refreshPeers();
}, 30000);

// ── Init ──
document.getElementById('myNickEl').textContent=myNick;

if (!navigator.bluetooth) {
  document.getElementById('no-ble').style.display='block';
  document.getElementById('btn-scan').disabled=true;
  document.getElementById('btn-scan').textContent='NO BLE';
  syslog('⚠ Web Bluetooth not available — use Chrome or Edge','err');
} else {
  syslog('web bluetooth available ✓','ok');
}

syslog(`you are ${myNick} · peer id ${myPeerId}`,'sys-msg');
syslog('type /help for commands · /nick <name> to change your nickname','sys-msg');
syslog('service: f47b5e2d-4a9e… · characteristic: a1b2c3d4-e5f6…','sys-msg');
syslog('compatible with bitchat iOS / Android native apps','sys-msg');
</script>
</body>
</html>
